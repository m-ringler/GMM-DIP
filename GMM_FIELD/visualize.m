%% visualize.m
% This file shows you
%   - how you can read GMM-FIELD results into MATLAB or GNU Octave
%   - how you can numerically calculate the magnetic field and the Poynting
%     vector from the electric field data generated by GMM-FIELD
%   - how you can visualize the data.
%
% (c) 2009, Moritz Ringler
% 

%% INPUT SECTION
% This section shows you how to read the GMM-FIELD configuration and result
% files into MATLAB or GNU Octave.

% datadir = fullfile('examples', 'au-2s', 'bek08', 'longitudinal');
% cd(datadir);

isOctave = exist('OCTAVE_VERSION', 'builtin');

%% Read the grid definition
fid = fopen('grid.in', 'r');
try
	line = fgetl(fid);
	ggrid(1,:) = sscanf(line, '%f', 3);
	line = fgetl(fid);
	ggrid(2,:) = sscanf(line, '%f', 3);
catch
    fclose(fid);
    rethrow(lasterror);
end
fclose(fid);
clear fid;

nx = ggrid(1,1);
ny = ggrid(1,2);
nz = ggrid(1,3);

%% Read the wave and particle definition
fid = fopen('au-2s-532nm.k', 'r');
try
	line = fgetl(fid);	
    	wavelength = sscanf(line, '%f', 1);
	line = fgetl(fid);	
	nParticles = sscanf(line, '%d', 1);
	for k=1:nParticles
		line = fgetl(fid);	
    		particles(k,:) = sscanf(line, '%f', 6);
    	end
catch
    fclose(fid);
    rethrow(lasterror);
end
fclose(fid);
clear fid;


%% Read the data
field = load('-ascii','field.dat');

%% Reshape the data
% In field.dat z is the slowest varying index, and x the fastest-varying.
% Therefore, we need to use reshape(..., nx, ny, nz)
field = reshape(field, nx, ny, nz, 10);
% And now we change the order to y, x, z because this is what meshgrid
% produces (3D plaid)
ftmp = zeros(size(field));
for n=1:10
    for kz=1:nz
        ftmp( :, :, kz, n) = field(:, :, kz, n).';
    end
end
field = ftmp;
clear ftmp;

%% Extract coordinate matrices and electric field vector components
% coordinate matrices
x = field(:,:,:,1);
y = field(:,:,:,2);
z = field(:,:,:,3);
% components of the electric field vector
ex = complex(field(:,:,:,4), field(:,:,:,5));
ey = complex(field(:,:,:,6), field(:,:,:,7));
ez = complex(field(:,:,:,8), field(:,:,:,9));
% absolute value of the electric field
eabs = field(:,:,:,10);
clear field;

%% Calculate the magnetic field and the time-averaged Poynting vector
% H and S are normalized such that their magnitudes are one
% in the absence of particles. 

if(exist('curl') == 0)
	% Calculate the curl with gradient. Completely untested code!
	% I haven't checked that this really does what it's supposed to do
	dx = x(1,2,1) - x(1,1,1);
	dy = y(2,1,1) - y(1,1,1);
	dz = z(1,1,2) - z(1,1,1);
	[ignore dyex dzex] = gradient(ex, dx, dy, dz);
	[dxey ignore dzey] = gradient(ey, dx, dy, dz);
	[dxez dyez ignore] = gradient(ey, dx, dy, dz);
	clear ignore;
	hx = dyez - dzey;
	hy = dzex - dxez;
	hz = dxey - dyex;	
	clear dx dy dz dyex dzex dxey dzey dxez dyez
else
	% MATLAB has a dedicated curl function
	[hx hy hz] = curl(x, y, z, ex, ey, ez);
end
h0 = -i * wavelength/2/pi;
hx = h0 * hx;
hy = h0 * hy;
hz = h0 * hz;
clear h0;

chx = conj(hx);
chy = conj(hy);
chz = conj(hz);
sx = 0.5 * real(ey .* chz - ez .* chy);
sy = 0.5 * real(ez .* chx - ex .* chz);
sz = 0.5 * real(ex .* chy - ey .* chx);
clear chx chy chz;
save field.mat

%% OUTPUT SECTION
% This section shows you how you can easily generate nice plots of your
% data with MATLAB or GNU Octave. This is just a glimpse of what is
% possible in MATLAB... 
% (read the help on volume visualization, velocity plots etc.)
%
%% Plot the norm of the electric field at the surface through z==0
% Extract the data at z == 0
kz = (nz + 1)/2;
eabs0 = squeeze(eabs(:,:, kz));
x_nm = squeeze(x(:,:, kz)) * 1000;
y_nm = squeeze(y(:,:, kz)) * 1000;
maxval = max(max(eabs0));

% Make a colormap that goes from black at 0 to blue at 1 and red at max(eabs)
% This should really be a function, but you cannot define subfunctions in
% script m files.
%
nColors = 256;
nBlue = round(nColors/maxval);
zeroToOne = zeros(nBlue, 3);
zeroToOne(:,3) = linspace(0,1,nBlue);
nHue = nColors - nBlue + 1;
oneToMax = ones(nHue, 3);
oneToMax(:,1) = linspace(2./3., 0, nHue);
oneToMax = hsv2rgb(oneToMax(2:end, :));
map = [ zeroToOne; oneToMax ];
colormap(map);

% Create the graph and annotate it
plotFunc = 'mesh'; % one of 'imagesc', 'surf', 'mesh'
if strcmp(plotFunc, 'imagesc')
    imagesc(x_nm(1,:), y_nm(:,1), eabs0, [0 maxval]);
    colorbar;
else
    f = str2func(plotFunc);
    f(x_nm, y_nm,  eabs0, eabs0 * nColors/maxval);
    set(gca, 'ZLimMode', 'manual', 'ZLim', [0 maxval]);
end
xlabel('x (nm)','interpreter', 'latex');
ylabel('y (nm)','interpreter', 'latex');
s = warning('off', 'MATLAB:tex');
title('Electric field strength $\|\mathbf{E}\|$ at $z = 0$', 'interpreter', 'latex');
warning(s);

% clear temporary/local variables
clear s map oneToMax nHue zeroToOne nBlue plotFunc nColors maxval kz eabs0 x_nm y_nm;

%% Plot a vector field
% As of v3.0.1 Octave has much poorer vector plotting capabilities than MATLAB, 
% and this section does not produce nice results in Octave
close all;

% Configuration
addParticles = false; % does not work properly in Octave
addWalls = false; % does not work properly in Octave

% Choose a real vector field
fields    = { 'e', 'h', 's' };
kfield = 3;
realfuncs = {'abs', 'imag', 'real' };
kfunc = 3;

% Calculate real vector field
realfunc = realfuncs{kfunc};
field =  fields{kfield};
switch field
    case 'e'
        f = str2func(realfunc);
        vfield = { f(ex), f(ey), f(ez) };
        ttitle = [realfunc '(' field ')'];
    case 'h'        
        f = str2func(realfunc);
        vfield = { f(hx), f(hy), f(hz) };        
        ttitle = [realfunc '(' field ')'];
    case 's'
        vfield = { sx, sy, sz};
        ttitle = 'time averaged Poynting vector';
    otherwise
        error('No such vector field %s', field);
end


maxx = abs(ggrid(2,1));
maxy = abs(ggrid(2,2));
maxz = abs(ggrid(2,3));

% Make a cone plot
if(exist('coneplot')  ~= 0)

[cx cy cz] = ...
    meshgrid(linspace(- 0.9 * maxx, 0.9 * maxx, 5),... 
    linspace(- 0.9 * maxy, 0.9 * maxy, 5),...
    linspace(- 0.9 * maxz, 0.9 * maxz, 5));
hcones = coneplot(x, y, z, vfield{1}, vfield{2}, vfield{3}, cx, cy, cz, 10);
set(hcones,'FaceColor','red','EdgeColor','none')
set(hcones,'DiffuseStrength',.8)
else
	figure(2);
	nq = 5;
	KX = linspace(1, nx, nq);
	KY = linspace(1, ny, nq);
	KZ = linspace(1, nz, nq);
	xx = x(KY, KX, KZ);
	yy = y(KY, KX, KZ);
	zz = z(KY, KX, KZ);
	vx = vfield{1};
	vx = vx(KY, KX, KZ);	
	vy = vfield{2};
	vy = vy(KY, KX, KZ);
	vz = vfield{3};
	vz = vz(KY, KX, KZ);
	hcones = quiver3(xx, yy, zz, vx, vy, vz, 0.2,'r');
end
axis tight;



% Calculate scalar field
sfield = sqrt(vfield{1}.^2 + vfield{2}.^2 + vfield{3}.^2);
maxval = max(sfield(:));

% Make walls
if addWalls
    hold on
    hsurfaces = slice(x,y,z,sfield,[-maxx,maxx],maxy,-maxz);
    set(hsurfaces,'FaceColor','interp','EdgeColor','none');
    hold off
    set(hsurfaces,'AmbientStrength',.6)
end

% Make a colormap that goes from black at 0 to blue at 1 and red at max(eabs)
nColors = 256;
plotFunc = 'mesh'; % one of 'imagesc', 'surf', 'mesh'
nBlue = round(nColors/maxval);
zeroToOne = zeros(nBlue, 3);
zeroToOne(:,3) = linspace(0,1,nBlue);
nHue = nColors - nBlue + 1;
oneToMax = ones(nHue, 3);
oneToMax(:,1) = linspace(2./3., 0, nHue);
oneToMax = hsv2rgb(oneToMax(2:end, :));
map = [ zeroToOne; oneToMax ];
set(gca, 'CLimMode', 'manual', 'CLim', [0 maxval]);
colormap(map);

axis([-maxx maxx -maxy maxy -maxz maxz]);
view(30,40);
if(exist('camproj')   ~= 0)
	camproj('perspective');
end
if(exist('camzoom')   ~= 0)
	camzoom(1.2);
end
if(exist('camlight')   ~= 0)
	camlight('right');
end
if(exist('lighting')   ~= 0)	
	 lighting('phong');
end


xlabel('x ($\mu$m)','interpreter', 'latex');
ylabel('y ($\mu$m)','interpreter', 'latex');
zlabel('z ($\mu$m)','interpreter', 'latex');

%% Add particles
if addParticles
    % Plot the dye-filled sphere
    n = 20;
    R = 0.02;
    theta = pi*(-n:2:n)/n;
    phi = (pi/2)*(-n:2:n)'/n;
    SX = cos(phi)*cos(theta);
    SY = cos(phi)*sin(theta);
    SZ = sin(phi)*ones(size(theta));
    hold on;
    mesh(R*SX,R*SY,R*SZ);
    hidden off; hold off;


    px = particles(:,1);
    py = particles(:,2);
    pz = particles(:,3);
    pr = particles(:,4);

    hold on;
    for k=1:nParticles
        R = pr(k);
        surf(R*SX + px(k), R*SY + py(k), R*SZ + pz(k), ones(size(SZ)) * maxval); hidden off;
    end
    hold off;


    maxx = max([maxx; px + pr]);
    minx = min([-maxx; px - pr]);
    maxy = max([maxy; py + pr]);
    miny = min([-maxy; py - pr]);
    maxz = max([maxz; pz + pr]);
    minz = min([-maxz; pz - pr]);

    axis([minx maxx miny maxy minz maxz]);
    axis equal; axis tight;
end
title(ttitle);